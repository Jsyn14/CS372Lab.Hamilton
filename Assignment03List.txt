# Project drop-in: `List<T>` (header‑only) + `Bag<T>` refactored to use `List`

**What you get here**

* `include/List.hpp` — a clean singly‑linked `List<T>` with full Rule‑of‑Five (copy/move ctor & assign), iterators, push/pop, insert/erase\_after, remove\_one, etc. 100% header‑only so templates compile without separate .cpp.
* `include/Bag.hpp` — `Bag<T>` reimplemented to use `List<T>` as its backing store (instead of `std::vector`). Typical bag ops: `insert`, `remove(value)` (one occurrence), `contains`, `count`, `size`, `empty`, `clear`.
* `tests/gtestlist.cpp` — small GoogleTest battery that exercises copy/move semantics and bag behavior.
* **Submission notes** explaining why the spec asks for *Bag* (not *ReceiptBag*) and why a `List` is appropriate.

---

## ✅ How to wire this into your existing CMake

Your CMake already pulls GoogleTest and compiles `gtestlist.cpp`. Drop the two headers under your repo’s `include/` folder and the test under `tests/` (or where your CMake expects it). With your snippet that has `include_directories(../../include)`, make sure the relative path lands on the folder that contains these two headers.

* Place:

  * `include/List.hpp`
  * `include/Bag.hpp`
  * `tests/gtestlist.cpp`

No `.cpp` files are required.

Run:

```bash
cmake -S . -B build
cmake --build build
ctest --test-dir build --output-on-failure
```

---

## `include/List.hpp`

```cpp
#pragma once
#include <cstddef>
#include <initializer_list>
#include <iterator>
#include <stdexcept>
#include <utility>

// A minimal, singly-linked List<T> that supports forward iteration, push_front/back,
// pop_front, insert_after, erase_after, remove_one, and full copy/move semantics.
// Header-only so templates compile without separate translation units.

template <typename T>
class List {
private:
    struct Node {
        T value;
        Node* next;
        Node(const T& v, Node* n = nullptr) : value(v), next(n) {}
        Node(T&& v, Node* n = nullptr) : value(std::move(v)), next(n) {}
    };

    Node* head_ = nullptr;
    Node* tail_ = nullptr;
    std::size_t size_ = 0;

public:
    // ===== Iterators (forward) =====
    class iterator {
        Node* cur_ = nullptr;
    public:
        using iterator_category = std::forward_iterator_tag;
        using value_type = T;
        using difference_type = std::ptrdiff_t;
        using pointer = T*;
        using reference = T&;

        iterator() = default;
        explicit iterator(Node* n) : cur_(n) {}
        reference operator*() const { return cur_->value; }
        pointer operator->() const { return &cur_->value; }
        iterator& operator++() { cur_ = cur_->next; return *this; }
        iterator operator++(int) { iterator tmp(*this); ++(*this); return tmp; }
        friend bool operator==(const iterator& a, const iterator& b) { return a.cur_ == b.cur_; }
        friend bool operator!=(const iterator& a, const iterator& b) { return a.cur_ != b.cur_; }
        friend class List;
    };

    class const_iterator {
        const Node* cur_ = nullptr;
    public:
        using iterator_category = std::forward_iterator_tag;
        using value_type = const T;
        using difference_type = std::ptrdiff_t;
        using pointer = const T*;
        using reference = const T&;

        const_iterator() = default;
        explicit const_iterator(const Node* n) : cur_(n) {}
        const_iterator(const iterator& it) : cur_(it.cur_) {}
        reference operator*() const { return cur_->value; }
        pointer operator->() const { return &cur_->value; }
        const_iterator& operator++() { cur_ = cur_->next; return *this; }
        const_iterator operator++(int) { const_iterator tmp(*this); ++(*this); return tmp; }
        friend bool operator==(const const_iterator& a, const const_iterator& b) { return a.cur_ == b.cur_; }
        friend bool operator!=(const const_iterator& a, const const_iterator& b) { return a.cur_ != b.cur_; }
    };

    // ===== Constructors / Rule of Five =====
    List() = default;

    List(std::initializer_list<T> ilist) : List() {
        for (const auto& v : ilist) push_back(v);
    }

    // Deep copy
    List(const List& other) : List() {
        for (const auto& v : other) push_back(v);
    }

    // Steal the links
    List(List&& other) noexcept : head_(other.head_), tail_(other.tail_), size_(other.size_) {
        other.head_ = other.tail_ = nullptr;
        other.size_ = 0;
    }

    ~List() { clear(); }

    List& operator=(const List& other) {
        if (this != &other) {
            List tmp(other); // copy-and-swap for strong exception safety
            swap(tmp);
        }
        return *this;
    }

    List& operator=(List&& other) noexcept {
        if (this != &other) {
            clear();
            head_ = other.head_;
            tail_ = other.tail_;
            size_ = other.size_;
            other.head_ = other.tail_ = nullptr;
            other.size_ = 0;
        }
        return *this;
    }

    void swap(List& other) noexcept {
        using std::swap;
        swap(head_, other.head_);
        swap(tail_, other.tail_);
        swap(size_, other.size_);
    }

    // ===== Capacity =====
    std::size_t size() const noexcept { return size_; }
    bool empty() const noexcept { return size_ == 0; }

    // ===== Iteration =====
    iterator begin() noexcept { return iterator(head_); }
    iterator end() noexcept { return iterator(nullptr); }
    const_iterator begin() const noexcept { return const_iterator(head_); }
    const_iterator end() const noexcept { return const_iterator(nullptr); }
    const_iterator cbegin() const noexcept { return const_iterator(head_); }
    const_iterator cend() const noexcept { return const_iterator(nullptr); }

    // ===== Element access =====
    T& front() {
        if (empty()) throw std::out_of_range("front() on empty List");
        return head_->value;
    }
    const T& front() const {
        if (empty()) throw std::out_of_range("front() on empty List");
        return head_->value;
    }
    T& back() {
        if (empty()) throw std::out_of_range("back() on empty List");
        return tail_->value;
    }
    const T& back() const {
        if (empty()) throw std::out_of_range("back() on empty List");
        return tail_->value;
    }

    // ===== Modifiers =====
    void clear() noexcept {
        Node* n = head_;
        while (n) { Node* next = n->next; delete n; n = next; }
        head_ = tail_ = nullptr;
        size_ = 0;
    }

    void push_front(const T& v) {
        Node* n = new Node(v, head_);
        head_ = n;
        if (!tail_) tail_ = n;
        ++size_;
    }
    void push_front(T&& v) {
        Node* n = new Node(std::move(v), head_);
        head_ = n;
        if (!tail_) tail_ = n;
        ++size_;
    }

    void push_back(const T& v) {
        Node* n = new Node(v, nullptr);
        if (tail_) tail_->next = n; else head_ = n;
        tail_ = n;
        ++size_;
    }
    void push_back(T&& v) {
        Node* n = new Node(std::move(v), nullptr);
        if (tail_) tail_->next = n; else head_ = n;
        tail_ = n;
        ++size_;
    }

    void pop_front() {
        if (empty()) throw std::out_of_range("pop_front() on empty List");
        Node* n = head_;
        head_ = head_->next;
        delete n;
        if (!head_) tail_ = nullptr;
        --size_;
    }

    // Insert after iterator position. If pos is end()/nullptr, inserts at front.
    iterator insert_after(const iterator& pos, const T& v) {
        if (pos.cur_ == nullptr) { // treat as insert at head
            push_front(v);
            return begin();
        }
        Node* n = new Node(v, pos.cur_->next);
        pos.cur_->next = n;
        if (tail_ == pos.cur_) tail_ = n;
        ++size_;
        return iterator(n);
    }

    // Erase the node after iterator position. If pos is end()/nullptr, erase head.
    iterator erase_after(const iterator& pos) {
        if (pos.cur_ == nullptr) { // erase head
            pop_front();
            return begin();
        }
        Node* target = pos.cur_->next;
        if (!target) throw std::out_of_range("erase_after() past end");
        pos.cur_->next = target->next;
        if (tail_ == target) tail_ = pos.cur_;
        delete target;
        --size_;
        return iterator(pos.cur_->next);
    }

    // Remove first node equal to value. Returns true if one was removed.
    bool remove_one(const T& value) {
        if (empty()) return false;
        if (head_->value == value) { pop_front(); return true; }
        Node* prev = head_;
        Node* cur = head_->next;
        while (cur) {
            if (cur->value == value) {
                prev->next = cur->next;
                if (cur == tail_) tail_ = prev;
                delete cur;
                --size_;
                return true;
            }
            prev = cur;
            cur = cur->next;
        }
        return false;
    }
};
```

---

## `include/Bag.hpp`

```cpp
#pragma once
#include <cstddef>
#include <utility>
#include "List.hpp"

// A simple multiset-like Bag backed by List<T>.
// Supports insert (adds one copy), remove(value) (removes one matching copy),
// contains, count, size, empty, clear.

template <typename T>
class Bag {
private:
    List<T> items_;

public:
    Bag() = default;
    Bag(const Bag&) = default;
    Bag(Bag&&) noexcept = default;
    Bag& operator=(const Bag&) = default;
    Bag& operator=(Bag&&) noexcept = default;
    ~Bag() = default;

    bool empty() const noexcept { return items_.empty(); }
    std::size_t size() const noexcept { return items_.size(); }
    void clear() noexcept { items_.clear(); }

    void insert(const T& value) { items_.push_back(value); }
    void insert(T&& value) { items_.push_back(std::move(value)); }

    // Remove a single occurrence of value; returns true if one was removed.
    bool remove(const T& value) { return items_.remove_one(value); }

    bool contains(const T& value) const {
        for (auto it = items_.begin(); it != items_.end(); ++it)
            if (*it == value) return true;
        return false;
    }

    std::size_t count(const T& value) const {
        std::size_t c = 0;
        for (auto it = items_.begin(); it != items_.end(); ++it)
            if (*it == value) ++c;
        return c;
    }
};
```

---

## `tests/gtestlist.cpp`

```cpp
#include <gtest/gtest.h>
#include <string>
#include "List.hpp"
#include "Bag.hpp"

TEST(ListBasics, PushPopFrontBack) {
    List<int> xs;
    EXPECT_TRUE(xs.empty());
    xs.push_back(1);
    xs.push_back(2);
    xs.push_front(0);
    EXPECT_EQ(xs.size(), 3u);
    EXPECT_EQ(xs.front(), 0);
    EXPECT_EQ(xs.back(), 2);
    xs.pop_front();
    EXPECT_EQ(xs.front(), 1);
}

TEST(ListCopyMove, CopyCtorAndIndependence) {
    List<int> a; a.push_back(1); a.push_back(2); a.push_back(3);
    List<int> b(a); // copy
    EXPECT_EQ(a.size(), 3u);
    EXPECT_EQ(b.size(), 3u);
    // Mutate b; a should remain intact
    b.pop_front();
    EXPECT_EQ(b.front(), 2);
    EXPECT_EQ(a.front(), 1);
}

TEST(ListCopyMove, CopyAssign) {
    List<std::string> a; a.push_back("one"); a.push_back("two");
    List<std::string> b; b.push_back("x");
    b = a; // copy-assign
    EXPECT_EQ(b.size(), 2u);
    EXPECT_EQ(b.front(), std::string("one"));
}

TEST(ListCopyMove, MoveCtorAndAssign) {
    List<int> a; a.push_back(10); a.push_back(20);
    List<int> b(std::move(a));
    EXPECT_EQ(b.size(), 2u);
    EXPECT_EQ(a.size(), 0u);

    List<int> c; c.push_back(7);
    c = std::move(b);
    EXPECT_EQ(c.size(), 2u);
    EXPECT_EQ(b.size(), 0u);
    EXPECT_EQ(c.front(), 10);
    EXPECT_EQ(c.back(), 20);
}

TEST(ListOps, InsertEraseAfter) {
    List<int> xs; xs.push_back(1); xs.push_back(3);
    auto it = xs.begin(); // at 1
    xs.insert_after(it, 2); // 1,2,3
    EXPECT_EQ(xs.size(), 3u);
    it = xs.begin();
    xs.erase_after(it); // erase 2 -> 1,3
    EXPECT_EQ(xs.size(), 2u);
    EXPECT_EQ(xs.back(), 3);
}

TEST(BagBasics, InsertRemoveContainsCount) {
    Bag<std::string> bag;
    bag.insert("apple");
    bag.insert("banana");
    bag.insert("apple");

    EXPECT_EQ(bag.size(), 3u);
    EXPECT_TRUE(bag.contains("banana"));
    EXPECT_EQ(bag.count("apple"), 2u);

    EXPECT_TRUE(bag.remove("apple"));
    EXPECT_EQ(bag.count("apple"), 1u);
    EXPECT_EQ(bag.size(), 2u);

    EXPECT_FALSE(bag.remove("cherry"));
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
```

---

## Submission Notes (include these in your write‑up)

**Why use `Bag` from lecture, not `ReceiptBag` from the earlier assignment?**

* A **Bag** is an **unordered multiset** abstraction: it models “a collection of items where order doesn’t matter and duplicates are allowed.” Its interface is value‑centric: *insert a value*, *remove one instance of a value*, *count how many of a value*, *check membership*, *size/empty/clear*.
* A **ReceiptBag** is a **different ADT** layered on top of a bag that issues **opaque receipts/handles** for each insertion and later removes by that handle. That design **assumes efficient random access or an index map** (typical backing store: `std::vector` or an array + freelist) so you can validate and delete by receipt quickly.
* A singly‑linked `List<T>` **does not provide random access** and therefore is **not a good fit** for “remove by receipt id” semantics. You *can* make it work by bolting on maps from receipt→node, but that mutates the data‑structure/complexity story and defeats the point of the exercise.

**Therefore the requirement** to refactor **`Bag<T>`** (not `ReceiptBag`) to use your new `List<T>` makes conceptual and algorithmic sense: operations are value‑oriented and naturally supported by a linked list with linear‑time scans and O(1) pushes at either end.

**Copy/Move semantics in `List<T>`**

* The lecture version didn’t address copy/move. This implementation provides:

  * **Copy constructor**: deep‑copies by iterating `other` and `push_back`ing each element.
  * **Copy assignment**: copy‑and‑swap for strong exception safety.
  * **Move constructor / move assignment**: pointer steal (sets source to empty) for O(1) moves.
  * **Destructor**: walks the list and deletes nodes.

**Complexities (amortized / worst‑case):**

* `push_front` / `pop_front` / `push_back`: **O(1)**
* `insert_after` / `erase_after`: **O(1)** given iterator
* `remove_one(value)`, `contains`, `count`: **O(n)** (scan)
* `size`, `empty`, `front`, `back`: **O(1)\`**

**Testing notes**

* `tests/gtestlist.cpp` exercises: basic pushes/pops, `insert_after`/`erase_after`, deep copy independence, move correctness (source emptied), and bag operations (`insert`, `remove`, `contains`, `count`).

---

## Optional: if you need index-like erase

If your lecture’s List ADT included index operations, prefer iterators for linked lists, but you can add a slow index helper:

```cpp
// Example helper (not used above): erase at zero-based index, O(n)
template <typename T>
typename List<T>::iterator erase_at(List<T>& xs, std::size_t idx) {
    if (idx == 0) { xs.pop_front(); return xs.begin(); }
    auto prev = xs.begin();
    for (std::size_t i = 0; i + 1 < idx && prev != xs.end(); ++i) ++prev;
    return xs.erase_after(prev);
}
```

Keep it out unless your rubric explicitly requires index-based methods.
